参考文章：
[从 4 个面试题了解「浏览器的垃圾回收」](https://mp.weixin.qq.com/s/hpMGNtHPN_T-Upg9V4L_Jg)


可达对象：
1. 可以访问到的对象就是可达对象（引用、作用域链）
2. 可达的标准就是从根出发是否能够被找到
3. 根可理解为全局变量对象

> 垃圾回收会阻塞程序执行

常见回收算法：
1. 引用计数
2. 标记清除
3. 标记整理

V8 垃圾回收算法：
1. 分代回收（新生代/老生代）
2. 标记清除
2. 标记整理
4. 增量标记（回收工作分片执行）

V8 内存设限：32位: 800M / 64位: 1.5G

* 左侧新生代 —— 32位: 8M / 64位: 16M
* 右侧老生代 —— 32位: 700M / 64位: 1.4G

> 新生代对象：存活时间短的对象，如局部变量

### 新生代对象回收（副垃圾回收器）
1. 回收过程采用复制算法 + 标记整理
2. 新生代内存区分为二个等大小空间: From/To
3. From: 使用空间，To: 空闲空间
4. 活动对象存储于 From 空间
5. From 快满后，标记整理后将活动对象拷贝至 To
6. From 与 To 交换空间完成释放（清除 From 空间，From 变成 To，To 变成 From）


回收细节：
1. 拷贝过程中可能出现晋升（新生代对象移动至老生代）
2. 一轮 GC 还存活的新生代需要晋升
3. To 空间使用率超过 25%，需将 To 空间所有新生代对象晋升，否则 To 转变为 From 后空间不太够用
4. 空间换时间（整片复制清除，From/To 切换）

### 老生代对象回收（主垃圾回收器）
1. 标记清除、标记整理、增量标记
2. 首先使用标记清除完成垃圾空间回收
3. 标记整理进行空间优化（老生代空间不足就会进行整理）
4. 增量标记进行效率优化（分片执行，无须整片执行，回收与程序频繁间隔切换执行）
